/*
 * CUP specification for the parser for a simple demo language.
 * Change this into the parser for your implementation of MiniJava.
 * CSE 401/P501 Au11.
 */

package Parser;

import AST.ASTNode;
import AST.ArrayAssign;
import AST.ArrayLength;
import AST.ArrayLookup;
import AST.Assign;
import AST.Block;
import AST.BooleanType;
import AST.Call;
import AST.ClassDecl;
import AST.ClassDeclExtends;
import AST.ClassDeclList;
import AST.ClassDeclSimple;
import AST.ConstantExp;
import AST.Display;
import AST.Exp;
import AST.ExpList;
import AST.False;
import AST.Formal;
import AST.FormalList;
import AST.Identifier;
import AST.IdentifierExp;
import AST.IdentifierType;
import AST.If;
import AST.IntArrayType;
import AST.IntegerLiteral;
import AST.IntegerType;
import AST.LessThan;
import AST.MainClass;
import AST.MethodDecl;
import AST.MethodDeclList;
import AST.Minus;
import AST.NewArray;
import AST.NewObject;
import AST.Not;
import AST.Plus;
import AST.Print;
import AST.Program;
import AST.ShortCircuitAnd;
import AST.Statement;
import AST.StatementList;
import AST.This;
import AST.Times;
import AST.True;
import AST.Type;
import AST.VarDecl;
import AST.VarDeclList;
import AST.While;
import java_cup.runtime.Symbol;

import java.util.LinkedList;
import java.util.List;

/* Code in the following section is included in the generated parser */

parser code {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message
   *  string and an additional object (to be used by specializations
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol) {
        if (((Symbol)info).left != -1) {
          System.err.println(" at line " + ((Symbol)info).left +
                             " of input");
        } else {
          System.err.println("");
        }
      } else {
        System.err.println("");
      }
    }
:};

/* end of code included in generated parser

/* Terminals (tokens returned by the scanner) */

/* reserved words: */
terminal DISPLAY;
terminal PRINT;

terminal CLASS;
terminal EXTENDS;
terminal NEW;

terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal STRING;

terminal INT;
terminal DOUBLE;
terminal BOOLEAN;

terminal IF;
terminal WHILE;
terminal RETURN;

terminal LENGTH;

terminal TRUE;
terminal FALSE;


/* operators: */
terminal EQUAL, NOTEQUAL, LESSTHAN, GREATERTHAN, LESSEQUAL, GREATEREQUAL;
terminal AND, OR;
terminal PLUS, MINUS, STAR, FSLASH, MOD, BECOMES, DOT, BANG;

/* delimiters: */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, SEMICOLON, COMMA;

/* tokens with values: */
terminal String IDENTIFIER;
terminal String CONSTANT;

/* comments */
terminal COMMENT;

/* Nonterminals */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Assign AssignStatement;
nonterminal Display DisplayStatement;
nonterminal Exp Expression;
nonterminal Identifier Identifier;


/* Precedence declarations */

precedence left PLUS;


/* Productions */

Program ::=
          Statement:s
            {:
              List<Statement> p = new LinkedList<Statement>();
              p.add(s);
              RESULT = p;
            :}
        | Program:p Statement:s
            {:
              p.add(s);
              RESULT = p;
            :}
        ;

Statement   ::=
          AssignStatement:s
            {: RESULT = s; :}
        | DisplayStatement:s
            {: RESULT = s; :}
        ;

AssignStatement ::=
          Identifier:id BECOMES Expression:expr SEMICOLON
            {: RESULT = new Assign(id, expr, idleft); :}
        ;

Identifier  ::=
          IDENTIFIER:id
            {: RESULT = new Identifier(id, idleft); :}
        ;

DisplayStatement ::=
          DISPLAY:d Expression:expr SEMICOLON
             {: RESULT = new Display(expr, dleft); :}
        ;

Expression    ::=
          IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, nameleft); :}

        | CONSTANT:value
            {: RESULT = new ConstantExp(value, valueleft); :}

        | Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1left); :}

        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :}
        ;
